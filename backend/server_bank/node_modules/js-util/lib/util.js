'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.functionParameters = exports.ns = exports.delay = exports.toType = exports.toBool = exports.toNumber = exports.isNumeric = exports.isBlank = exports.isPlainObject = exports.compact = undefined;

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a copy of the array with falsey values removed.
 * Removes:
 *   - null
 *   - undefined
 *   - empty-string ('')
 *
 * @param {Array} value: The value to examine.
 * @return {Array}.
 */
var compact = exports.compact = function compact(value) {
  return _ramda2.default.pipe(_ramda2.default.reject(_ramda2.default.isNil), _ramda2.default.reject(_ramda2.default.isEmpty))(value);
};

/**
 * Determines whether the value is a simple object (ie. not a class instance).
 * @param value: The value to examine.
 * @return {Boolean}.
 */
/* global setTimeout, clearTimeout */
var isPlainObject = exports.isPlainObject = function isPlainObject(value) {
  if (_ramda2.default.is(Object, value) === false) return false;

  // Not plain if it has a modified constructor.
  var ctr = value.constructor;
  if (typeof ctr !== 'function') {
    return false;
  }

  // If has modified prototype.
  var prot = ctr.prototype;
  if (_ramda2.default.is(Object, prot) === false) {
    return false;
  }

  // If the constructor does not have an object-specific method.
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Finish up.
  return true;
};

/**
* A safe way to test any value as to wheather is is 'blank'
* meaning it can be either:
*   - null
*   - undefined
*   - empty-string ('')
*   - empty-array ([]).
*/
var isBlank = exports.isBlank = function isBlank(value) {
  if (value === null || value === undefined) {
    return true;
  }
  if (_ramda2.default.is(Array, value) && compact(value).length === 0) {
    return true;
  }
  if (_ramda2.default.is(String, value) && value.trim() === '') {
    return true;
  }
  return false;
};

/**
* Determines whether the given value is a number, or can be
* parsed into a number.
*
* NOTE: Examines string values to see if they are numeric.
*
* @param value: The value to examine.
* @returns true if the value is a number.
*/
var isNumeric = exports.isNumeric = function isNumeric(value) {
  if (isBlank(value)) {
    return false;
  }
  var number = parseFloat(value);
  if (number === undefined) {
    return false;
  }
  if (number.toString().length !== value.toString().length) {
    return false;
  }
  return !Number.isNaN(number);
};

/**
 * Converts a value to a number if possible.
 * @param value: The value to convert.
* @returns the converted number, otherwise the original value.
 */
var toNumber = exports.toNumber = function toNumber(value) {
  if (isBlank(value)) {
    return value;
  }
  var number = parseFloat(value);
  if (number === undefined) {
    return value;
  }
  if (number.toString().length !== value.toString().length) {
    return value;
  }
  return Number.isNaN(number) ? value : number;
};

/**
* Converts a value to boolean (if it can).
* @param value: The value to convert.
* @param defaultValue: The value to return if the given value is null/undefined.
* @returns the converted boolean, otherwise the original value.
*/
var toBool = exports.toBool = function toBool(value, defaultValue) {
  if (_ramda2.default.isNil(value)) {
    return defaultValue;
  }
  if (_ramda2.default.is(Boolean, value)) {
    return value;
  }
  var asString = value.toString().trim().toLowerCase();
  if (asString === 'true') {
    return true;
  }
  if (asString === 'false') {
    return false;
  }
  return defaultValue;
};

/**
 * Converts a string it's actual type if it can be derived.
 * @param {string} string: The string to convert.
 * @return the original or converted value.
 */
var toType = exports.toType = function toType(value) {
  if (!_ramda2.default.is(String, value)) {
    return value;
  }
  var lowerCase = value.toLowerCase().trim();

  // Boolean.
  if (lowerCase === 'true') {
    return true;
  }
  if (lowerCase === 'false') {
    return false;
  }

  // Number.
  var number = toNumber(lowerCase);
  if (_ramda2.default.is(Number, number)) {
    return number;
  }

  // Originanl type.
  return value;
};

/**
* Provides a more convenient way of setting a timeout.
*
* @param msecs:  The milliseconds to delay.
* @param func:   The function to invoke.
*
* @returns  The timer handle.
*           Use the [stop] method to cancel the timer.
*/
var delay = exports.delay = function delay(msecs, func) {
  // Check parameters.
  if (_ramda2.default.is(Function, msecs)) {
    func = msecs;
    msecs = 0; // Immediate 'defer' when no milliseconds value specified.
  }
  if (_ramda2.default.is(Function, func)) {
    // Return an object with the running timer.
    return {
      msecs: msecs,
      id: setTimeout(func, msecs),
      stop: function stop() {
        clearTimeout(this.id);
      }
    };
  }
  return undefined;
};

/**
* Safely creates the given namespace on the root object.
*
* @param root:      The root object.
* @param namespace: The dot-delimited NS string (excluding the root object).
* @param options:
*           - delimiter: The namespace delimiter. Default '.'
*
* @returns the child object of the namespace.
*/
var ns = exports.ns = function ns(root, namespace) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  if (_ramda2.default.is(String, root) || _ramda2.default.is(Array, root)) {
    namespace = root;
    root = null;
  }
  if (isBlank(namespace)) {
    return undefined;
  }

  var getOrCreate = function getOrCreate(parent, name) {
    parent[name] = parent[name] || {};
    return parent[name];
  };

  var add = function add(parent, parts) {
    var part = getOrCreate(parent, parts[0]);
    if (parts.length > 1) {
      parts.splice(0, 1);
      part = add(part, parts); // <= RECURSION.
    }
    return part;
  };

  // Build the namespace.
  var delimiter = options.delimiter || '.';
  if (!_ramda2.default.is(Array, namespace)) {
    namespace = namespace.split(delimiter);
  }
  return add(root, namespace);
};

/*
  Determines the parameter names of a function

    See: http://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically-from-javascript

  @param func: The function to examine.
  @returns an array of strings.

*/
var functionParameters = exports.functionParameters = function functionParameters(func) {
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
  var ARGUMENT_NAMES = /([^\s,]+)/g;
  if (!_ramda2.default.is(Function, func)) {
    return [];
  }
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  if (result === null) {
    result = [];
  }
  return result;
};
//# sourceMappingURL=util.js.map