'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _compileStylus = require('./compile-stylus');

var _compileStylus2 = _interopRequireDefault(_compileStylus);

var _loadCss = require('./load-css');

var _loadCss2 = _interopRequireDefault(_loadCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var merge = function merge(sourceFiles, targetFiles) {
  return targetFiles.map(function (item) {
    var index = _ramda2.default.findIndex(function (m) {
      return m.path === item.path;
    }, sourceFiles);
    if (index > -1) {
      item.css = sourceFiles[index].css;
    }
    return item;
  });
};

var concatenate = function concatenate(files) {
  var css = _ramda2.default.pipe(_ramda2.default.map(_ramda2.default.prop('css')), _ramda2.default.reject(_ramda2.default.isNil));
  var append = function append(result, file) {
    return result += '\n\n\n' + file;
  };
  return _ramda2.default.reduce(append, '', css(files));
};

var saveToDisk = function saveToDisk(fileCache, files) {
  var toPayload = _ramda2.default.map(function (item) {
    return {
      key: item.path,
      value: { path: item.path, css: item.css }
    };
  });
  return fileCache.save(toPayload(files));
};

exports.default = function (fileCache, paths) {
  var files = void 0;
  var compiledFiles = void 0;

  return new Promise(function (resolve, reject) {
    // Read in any existing items from cache.
    //  - store the cached CSS on the return object.
    //  - remove that existing item from the list to compile.
    fileCache.load().then(function (cached) {

      var cachedFiles = _ramda2.default.filter(function (item) {
        return item.value;
      })(cached.files);
      var cachedPaths = _ramda2.default.map(function (item) {
        return item.value.path;
      })(cachedFiles);
      var isCached = function isCached(path) {
        return _ramda2.default.contains(path)(cachedPaths);
      };
      var cachedFile = function cachedFile(path) {
        return _ramda2.default.find(function (item) {
          return item.value.path === path;
        })(cachedFiles);
      };
      var uncachedPaths = _ramda2.default.reject(isCached, paths);

      // Create the return array.
      //  - populate with any CSS that already exists in the cache.
      files = paths.map(function (path) {
        var fromCache = cachedFile(path);
        var css = fromCache ? fromCache.value.css : undefined;
        return { path: path, css: css };
      });

      // Compile stylus.
      _compileStylus2.default.compile(uncachedPaths).then(function (result) {
        return compiledFiles = result;
      }).catch(function (err) {
        return reject(err);
      })

      // Merge the compiled files into the result set.
      .then(function () {
        return files = merge(compiledFiles, files);
      })

      // Cache CSS to disk.
      .then(function () {
        return saveToDisk(fileCache, compiledFiles);
      })

      // Add raw CSS files (.css)
      .then(function () {
        (0, _loadCss2.default)(paths).then(function (result) {
          return files = merge(result, files);
        }).then(function () {
          // Concatenate into final result.
          try {
            resolve({ files: files, css: concatenate(files) });
          } catch (e) {
            reject(e);
          }
        });
      }).catch(function (err) {
        return reject(err);
      });
    });
  });
};
//# sourceMappingURL=compile.js.map