'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CACHE_PATH = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsWatch = require('./fs-watch');

var _fsWatch2 = _interopRequireDefault(_fsWatch);

var _util = require('./util');

var util = _interopRequireWildcard(_util);

var _compile2 = require('./compile');

var _compile3 = _interopRequireDefault(_compile2);

var _cache = require('./cache');

var _cache2 = _interopRequireDefault(_cache);

var _fileSystemCache = require('file-system-cache');

var _fileSystemCache2 = _interopRequireDefault(_fileSystemCache);

var _cleanCss = require('clean-css');

var _cleanCss2 = _interopRequireDefault(_cleanCss);

var _const = require('./const');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CACHE_PATH = exports.CACHE_PATH = './.build/css';

var DEFAULTS = {
  watch: false, // Flag indicating if file-system watching is enabled.
  minify: false, // Flag indicating if the css should be minified.
  cache: true, // Flag indicating if caching should be employed.
  pathsRequired: true };

// Flag indicating if an error should be thrown if the
// given paths do not exist.
exports.default = {
  defaults: DEFAULTS,

  /**
   * Clears the memory and file cache.
   */
  delete: function _delete() {
    _fsExtra2.default.removeSync(_path2.default.resolve(CACHE_PATH));
    _cache2.default.clear();
  },


  /**
   * Starts a compiler for the given path(s).
   * @param {string|array} paths: The file-system paths to compile.
   * @param {object} options.
   * @return {Promise}
   */
  compile: function compile(paths) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // Setup initial conditions.
    var cacheKey = _cache2.default.key(paths, options);
    options.minify = options.minify || DEFAULTS.minify;
    options.cache = _ramda2.default.isNil(options.cache) ? DEFAULTS.cache : options.cache;
    options.watch = options.watch || DEFAULTS.watch;
    options.pathsRequired = options.pathsRequired === undefined ? DEFAULTS.pathsRequired : options.pathsRequired;

    // Check the cache.
    if (options.cache === true) {
      var _ret = function () {
        var css = _cache2.default.value(cacheKey);
        if (css) {
          // The value exists in the cache - return from here.
          return {
            v: new Promise(function (resolve) {
              return resolve({ css: css });
            })
          };
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    // Prepare the paths.
    if (!_ramda2.default.is(Array, paths)) {
      paths = _ramda2.default.reject(_ramda2.default.isNil, [paths]);
    }
    if (paths.length === 0) {
      throw new Error('File-system \'path\' was not specified.');
    }

    paths = _ramda2.default.pipe(_ramda2.default.flatten, _ramda2.default.map(function (path) {
      return path && path.startsWith('.') ? _path2.default.resolve(path) : path;
    }), _ramda2.default.reject(_ramda2.default.isNil), _ramda2.default.uniq)(paths);

    paths.forEach(function (path, i) {
      if (!_fsExtra2.default.existsSync(path)) {
        if (options.pathsRequired === true) {
          throw new Error('The CSS path \'' + path + '\' does not exist.');
        } else {
          paths[i] = null;
        }
      }
    });
    paths = _ramda2.default.reject(_ramda2.default.isNil, paths);

    // Retrieve all CSS source files within the given folders.
    paths.files = _ramda2.default.pipe(_ramda2.default.map(function (path) {
      return util.childPaths(path);
    }), _ramda2.default.flatten, _ramda2.default.filter(function (path) {
      return _ramda2.default.contains(_path2.default.extname(path), _const.EXTENSIONS);
    }), _ramda2.default.uniq)(paths);

    // Create the unique namespace for the compiler.
    var fileCache = (0, _fileSystemCache2.default)({
      basePath: CACHE_PATH,
      ns: paths.map(function (item) {
        return item;
      })
    });

    // Watch the files if in development mode.
    if (options.watch === true) {
      (0, _fsWatch2.default)(fileCache, paths.files); // Start the file-system watcher.
    }

    // Construct the return promise.
    var promise = new Promise(function (resolve, reject) {
      (0, _compile3.default)(fileCache, paths.files).then(function (result) {
        if (options.minify === true) {
          result.css = new _cleanCss2.default().minify(result.css).styles;
        }
        if (options.cache === true) {
          _cache2.default.value(cacheKey, result.css);
        }
        resolve(result);
      }).catch(function (err) {
        return reject(err);
      });
    });
    promise.options = options;
    promise.paths = paths;

    // Finish up.
    return promise;
  }
};
//# sourceMappingURL=index.js.map